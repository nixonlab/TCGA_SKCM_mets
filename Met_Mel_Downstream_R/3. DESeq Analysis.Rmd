---
title: "3. DESeq Analysis (Clusters and Status)"
author: "Phoebe Fei"
date: "2023-04-27"
output: 
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
---

```{css style_settings, echo = FALSE}
blockquote { 
    font-size: 14px; 
    font-style: italic;
}
h1{
    font-size: 22px;
}
h2{
    font-size: 20px;
}
h3{
    font-size: 18px;
}
h4{
    font-size: 16px;
}

```

## Libraries

```{r, message=FALSE}
library(stringr)
library(DESeq2)
library(vsn)
library(ggplot2)
library(apeglm)
library(dplyr)
library(tidyverse)
library(magrittr)
library(pheatmap)
library(EnhancedVolcano)
library(viridis)
library(biomaRt)
library(PCAtools)
library(UpSetR)
library(edgeR)
library(scopetools)
library(readxl)
library(ConsensusClusterPlus)
library(matrixStats)
library(glmnet)
library(Boruta)
library(c060)
library(randomForest)
library(rpart)
library(rpart.plot)
library(scCustomize)
library(sets)
library(survival)
library(survminer)
library(clusterProfiler)
library(org.Hs.eg.db)
library(DOSE)
library(pathview)
library(ggnewscale)
```


## Functions

### Result Table & HeatMap Table Generation

Result Table

```{r}
restable <- function(min_fc = 2, max_p = 0.05, n_top_genes = 20, deseq, cont, exclude_gene = ""){
  MIN_L2FC=log2(min_fc)
  res_table <- results(deseq, independentFiltering = TRUE, contrast = cont) %>% as.data.frame(.) %>% dplyr::select(everything()) %>%
    filter(log2FoldChange >= min_fc | log2FoldChange <= -min_fc ) %>%
    filter(padj <= max_p) %>%
    arrange(padj)
  if(length(exclude_gene) > 1 ){
    res_table <- res_table[-which(rownames(res_table) %in% exclude_gene),] %>% arrange(padj)
  }
  if(nrow(res_table) > n_top_genes){
    print(res_table[1:n_top_genes, ])}
  else{
    print(res_table)
  }
  return(res_table)
}
```

Heatmap Table

```{r}
#include a exclude genes so that some background genes might be excluded; select top = 40 based on p values
heattable <- function(deseq, res_table, select_string = "^(ERV|HERV|LTR|MER|HML).+",min_fc = 2, max_p = 0.05, select_genes = 40, exclude_genes = ""){
  #rlog scaled
  deseq.vst <- varianceStabilizingTransformation(deseq, blind = TRUE)
  #select padj
  seg.herv <- subset(res_table, padj < max_p & (log2FoldChange > log2(min_fc) | log2FoldChange < -log2(min_fc)))
  #Select the HREVs/Genes
  herv_names  <- str_extract(rownames(seg.herv), select_string)
  seg.herv.1 <- seg.herv[(rownames(seg.herv) %in%  herv_names),]
  seg.herv.1 <- seg.herv.1[!(rownames(seg.herv.1) %in% exclude_genes),]
  if(nrow(seg.herv.1) < select_genes){
    print(paste0("Only ", nrow(seg.herv.1), "rows significant after exclusion. Keeping all."))
    vst.herv <- deseq.vst[rownames(seg.herv.1),] %>% assay
  }else{
    seg.herv.1 <- arrange(seg.herv.1, padj)
    vst.herv <- deseq.vst[rownames(seg.herv.1[1:select_genes,]),] %>% assay
  }
  return(vst.herv)
}

```


Color scales
```{r}
# Save as variable to global environment
col_blind_p <- ColorBlind_Pal()
glas32 <- DiscretePalette_scCustomize(num_colors = 32, palette = "glasbey")
polyc<- DiscretePalette_scCustomize(num_colors = 36, palette = "polychrome", shuffle_pal = TRUE)
varibow <- DiscretePalette_scCustomize(num_colors = 50, palette = "varibow")
cluster_col <- c()
cluster_factors <- c("C1","C2","C3","C4","C5","Metastatic","Primary")
for(i in 1:length(cluster_factors)){
  cluster_col[unique(cluster_factors)[i]] <- col_blind_p[i]
}
feature_col <- c()
feature_selections <- c("BORUTA and LRT", "BORUTA and LASSO",   "LASSO and LRT" , "All Consensus","LASSO Unique" ,  "BORUTA Unique" ,"LRT Unique")
for(i in 1:length(unique(feature_selections))){
  feature_col[unique(feature_selections)[i]] <- polyc[i]
}
```

# Load Data

```{r}
load("/Users/phoebefei/Desktop/WCM/Mets Melanoma/TCGA SKCM/RData/2.Unsupervised Clustering and PCA.RData")

```


## Genes


```{r}
filtered_gene_counts <- filt_gene[DESeq.gene.un.pca$xvars,]
```

### Between Clusters

```{r}
#create the object
DESeq.gene.clusters <- DESeqDataSetFromMatrix(countData = filtered_gene_counts[,rownames(mets_selected)],
                                   colData = mets_selected,
                                   design = ~ Gene_clusters)
```


#### Process count info 
```{r, fig.width = 10, fig.height = 5}
#size factor
DESeq.gene.clusters <- estimateSizeFactors(DESeq.gene.clusters)
#normalize & log-sized
DESeq.gene.clusters_norm <- counts(DESeq.gene.clusters, normalized = TRUE)
boxplot(log2(DESeq.gene.clusters_norm+1), notch=FALSE, main = "Size-factor-normalized read counts\nGene Counts", ylab="log2(read counts)", cex = .6, las = 2)
assay(DESeq.gene.clusters,"log.norm.counts") <- log2(DESeq.gene.clusters_norm+1)
```


```{r}
#SD and PCA plot
msd.gene <- vsn::meanSdPlot(DESeq.gene.clusters@assays@data@listData$log.norm.counts, ranks=FALSE, plot = FALSE)
msd.gene$gg + ggtitle("Sequencing depth normalized log2(read counts), genes") + ylab("standard deviation")
```

Perform the test
```{r}
DESeq.gene.clusters <- DESeq(DESeq.gene.clusters ,parallel = T,test = "Wald", betaPrior = T)
resultsNames(DESeq.gene.clusters)
```

QQ Plot

```{r}
res_gene_clusters.all <- as.data.frame(results(DESeq.gene.clusters))
Norm_quantile<- sort(-log10(seq(1, 1/nrow(res_gene_clusters.all), length.out = nrow(res_gene_clusters.all))), decreasing = TRUE)
res_gene_clusters.all <-res_gene_clusters.all[order(res_gene_clusters.all$padj, decreasing  = FALSE),]
res_gene_clusters.all["Normal_Quantile"] <- Norm_quantile
ggplot(res_gene_clusters.all, aes(x = Normal_Quantile, y =-log10(padj))) + geom_point()+geom_abline(intercept = 0, slope = 1, color="red") + xlab("Negative Log Normal Quantile (Expected)")+ylab("Negative Log 10 P Values (Observed)")+ggtitle("QQ Plot for Computed Cluster Gene Expression")
```


### Feature Selection

#### LRT

```{r}
DESeq.gene.cluster.lrt <- DESeqDataSetFromMatrix(countData = filtered_gene_counts[,rownames(mets_selected)],
                                   colData = mets_selected,
                                   design = ~ Gene_clusters) 
DESeq.gene.cluster.lrt <- DESeq(DESeq.gene.cluster.lrt ,parallel = T,test = "LRT", reduced = ~1)
res_gene_clusters <- restable(min_fc = 2, max_p = 0.01, n_top_genes = 20, DESeq.gene.cluster.lrt)
```


```{r}
selected_genes_clusters <- list()
selected_genes_clusters$lrt <- rownames(res_gene_clusters) 
```



#### Boruta

```{r}
genes.clusters.vst <- assay(varianceStabilizingTransformation(DESeq.gene.clusters))
ntop.gene.c <- nrow(genes.clusters.vst)
vars.gene.c <- rowVars(genes.clusters.vst)
Vstmat.gene.clusters <- genes.clusters.vst[order(-vars.gene.c)[1:ntop.gene.c],]
```


```{r, message = FALSE}
set.seed(12345678)
bor.orig.cluster.gene <- Boruta(x = t(Vstmat.gene.clusters), y = mets_selected$Gene_clusters, doTrace=2, ntree = 1000, maxRuns = 1000)
print(bor.orig.cluster.gene)
bor.model.cluster.gene <- TentativeRoughFix(bor.orig.cluster.gene)
print(bor.model.cluster.gene)
selected_genes_clusters$boruta <- names(bor.model.cluster.gene$finalDecision)[bor.model.cluster.gene$finalDecision == 'Confirmed']
```

#### LASSO

```{r}
set.seed(123456)
gene.cluster_cv <- cv.glmnet(x = t(Vstmat.gene.clusters), y = mets_selected$Gene_clusters, family="multinomial",intercept = F, alpha=1)
gene.cluster.cf <- coef(gene.cluster_cv , gene.cluster_cv$lambda.1se)
gene_cluster.features.1 <- as.data.frame(gene.cluster.cf$C1)
gene_cluster1.feat<- rownames(gene_cluster.features.1)[gene_cluster.features.1!=0]
gene_cluster.features.2 <- as.data.frame(gene.cluster.cf$C2)
gene_cluster2.feat<- rownames(gene_cluster.features.2)[gene_cluster.features.2!=0]
gene_cluster.features.3 <- as.data.frame(gene.cluster.cf$C3)
gene_cluster3.feat<- rownames(gene_cluster.features.3)[gene_cluster.features.3!=0]
gene_cluster.features.4 <- as.data.frame(gene.cluster.cf$C4)
gene_cluster4.feat<- rownames(gene_cluster.features.4)[gene_cluster.features.4!=0]
selected_gene.cluster.lasso <-append(gene_cluster1.feat,append(gene_cluster2.feat,append(gene_cluster3.feat, gene_cluster4.feat)))
selected_gene.cluster.lasso<-selected_gene.cluster.lasso[!duplicated(selected_gene.cluster.lasso)]
selected_genes_clusters$lasso <- selected_gene.cluster.lasso
``` 


#### Consensus

```{r}
upset(fromList(selected_genes_clusters), 
      sets=c('lrt', 'boruta','lasso'), 
      order.by = "freq",
      text.scale = c(1.5, 1.5, 1.3, 1.3, 1.3, 1.3))
```


Heatmap table

```{r}
#Add a column to res_gene_clusters about the feature selection results
res_gene_clusters.all$Feature_Select <- rep(NA,nrow(res_gene_clusters.all))
#lrt
res_gene_clusters.all[selected_genes_clusters$lrt,"Feature_Select"] <- "LRT Unique"
#boruta
res_gene_clusters.all[selected_genes_clusters$boruta,"Feature_Select"] <- "BORUTA Unique"
#lasso
res_gene_clusters.all[selected_genes_clusters$lasso,"Feature_Select"] <- "LASSO Unique"
#boruta & lasso
las_bor <- intersect(selected_genes_clusters$boruta,selected_genes_clusters$lasso)
res_gene_clusters.all[las_bor,"Feature_Select"] <- "BORUTA and LASSO"
#boruta & lrt
bor_lrt <- intersect(selected_genes_clusters$boruta,selected_genes_clusters$lrt)
res_gene_clusters.all[bor_lrt,"Feature_Select"] <- "BORUTA and LRT"
#lasso & lrt
las_lrt <- intersect(selected_genes_clusters$lasso,selected_genes_clusters$lrt)
res_gene_clusters.all[las_lrt,"Feature_Select"] <- "LASSO and LRT"
#all three
all_3_gene <- intersect(las_lrt,selected_genes_clusters$boruta)
res_gene_clusters.all[all_3_gene,"Feature_Select"] <- "All Consensus"
#none (to be removed)
gene_heat_clusters <- genes.clusters.vst[rownames(res_gene_clusters.all)[(!is.na(res_gene_clusters.all$Feature_Select))],]
res_gene_clusters_selected <- res_gene_clusters.all[rownames(res_gene_clusters.all)[(!is.na(res_gene_clusters.all$Feature_Select))],]
gene_heat_clusters <- gene_heat_clusters[,order(mets_selected$Gene_clusters,rev(unsupervised.genes.clusters[[4]]$consensusTree$order))]
```


#### Functional pathway analyses and reordering the gene rows

Adapted from (hbctraining)[https://hbctraining.github.io/DGE_workshop_salmon/lessons/functional_analysis_2019.html]
```{r}
gene.cluster.go <- enrichGO(gene = as.character(gene_annot[rownames(res_gene_clusters_selected), "gene_name"]),
                            universe = as.character(gene_annot[rownames(res_gene_clusters.all), "gene_name"]),
                            keyType = "SYMBOL",
                            OrgDb = org.Hs.eg.db, 
                            ont = "BP", 
                            pAdjustMethod = "BH", 
                            qvalueCutoff = 0.05, 
                            readable = TRUE )
gene.cluster.go.summary <- as.data.frame(gene.cluster.go)
```



#### Visualization

Gene functional analyses

```{r, fig.height=12, fig.width = 6}
dotplot(gene.cluster.go, showCategory = 20) + ggtitle("Enrichment Analysis\nSignificant DE Genes Btwn Gene Clusters")+theme( plot.title=element_text(size=12,face="bold"),axis.title=element_text(size=8))

```



```{r, fig.height= 20, fig.width = 20}
gene_cluster_pair <- enrichplot::pairwise_termsim(gene.cluster.go)
emapplot(gene_cluster_pair, showCategory = 20) + ggtitle("Enrichment Map\nSignificant DE Genes Btwn Gene Clusters")+theme( plot.title=element_text(size=50,face="bold"),axis.title=element_text(size=20,face="bold"))

```


Heatmap

```{r,fig.height = 18, fig.width = 15}
breaklist <- seq(-3, 3, by = 0.25)
feature_col_genes <- feature_col[unique(res_gene_clusters_selected$Feature_Select)]
cluster_col_genes <- cluster_col[c("C1","C2","C3","C4")]
status_col <- cluster_col[c("Primary","Metastatic")]
pheatmap(gene_heat_clusters, scale="row",main = "Feature Selected DE Genes, Computed Clusters",fontsize = 20, size = 35, color = inferno(25), show_rownames = FALSE, show_colnames = FALSE,cluster_cols = FALSE, cluster_rows = TRUE, breaks = breaklist, legend_labels = "Expression Z-score", annotation_col = mets_selected[,c("Gene_clusters","Status"), drop = FALSE],annotation_row = res_gene_clusters_selected[,"Feature_Select",drop = FALSE], gaps_col = c(38,112,140),annotation_colors = list(Gene_clusters = cluster_col_genes, Status = status_col, Feature_Select = feature_col_genes))
```

```{r,fig.height = 10, fig.width = 18}
gene_heat_clusters_sub <- gene_heat_clusters[all_3_gene, ,drop = FALSE]
rownames(gene_heat_clusters_sub) <- gene_annot[rownames(gene_heat_clusters_sub), "gene_name"]
pheatmap(gene_heat_clusters_sub, scale="row",main = "Feature Selected DE Genes, Between Clusters\nShowing Only All Selected Consensus",fontsize = 20, size = 35, color = inferno(25), show_rownames = TRUE, show_colnames = FALSE,cluster_cols = FALSE, cluster_rows = TRUE, breaks = breaklist, legend_labels = "Expression Z-score", annotation_col = mets_selected[,c("Gene_clusters","Status"), drop = FALSE], gaps_col = c(38,112,140),annotation_colors = list(Gene_clusters = cluster_col_genes,Status = status_col))
```

Volcano Plot

```{r, fig.height = 18, fig.width = 20}
res_gene_clusters.all$Selected_gene <- rep("",nrow(res_gene_clusters.all))
res_gene_clusters.all[all_3_gene,"Selected_gene"] <- all_3_gene
consensus_gene_name <- intersect(rownames(gene_annot), all_3_gene)
res_gene_clusters.all[consensus_gene_name,"Selected_gene"] <- gene_annot[consensus_gene_name, "gene_name"]
EnhancedVolcano(res_gene_clusters.all,lab = res_gene_clusters.all$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "Gene Vocalno, Among Clusters\nLabeled Gene Name Consensus for Feature Selections",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```

For each clusters vs. others

C1
```{r, fig.height = 18, fig.width = 20}
C1_clusters <- results(DESeq.gene.clusters, independentFiltering = TRUE, contrast = list(c("Gene_clustersC1"), c("Gene_clustersC2","Gene_clustersC3","Gene_clustersC4")), listValues=c(1, -1/3)) %>% as.data.frame(.)
C1_clusters$Selected_gene <- rep("",nrow(C1_clusters))
c1_consensus_gene <- intersect(rownames(gene_annot), intersect(selected_genes_clusters$boruta, intersect(selected_genes_clusters$lrt, gene_cluster1.feat)))
C1_clusters[c1_consensus_gene,"Selected_gene"] <- gene_annot[c1_consensus_gene, "gene_name"]
EnhancedVolcano(C1_clusters,lab = C1_clusters$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "Gene Vocalno, Cluster1 vs. All\nLabeled Gene Name Consensus for Feature Selections",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```

C2

```{r, fig.height = 18, fig.width = 20}
C2_clusters <- results(DESeq.gene.clusters, independentFiltering = TRUE, contrast = list(c("Gene_clustersC2"), c("Gene_clustersC1","Gene_clustersC3","Gene_clustersC4")), listValues=c(1, -1/3)) %>% as.data.frame(.)
C2_clusters$Selected_gene <- rep("",nrow(C2_clusters))
c2_consensus_gene <- intersect(rownames(gene_annot), intersect(selected_genes_clusters$boruta, intersect(selected_genes_clusters$lrt, gene_cluster2.feat)))
C2_clusters[c2_consensus_gene,"Selected_gene"] <- gene_annot[c2_consensus_gene, "gene_name"]
EnhancedVolcano(C2_clusters,lab = C2_clusters$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "Gene Vocalno, Cluster2 vs. All\nLabeled Gene Name Consensus for Feature Selections",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```

C3

```{r, fig.height = 18, fig.width = 20}
C3_clusters <- results(DESeq.gene.clusters, independentFiltering = TRUE, contrast = list(c("Gene_clustersC3"), c("Gene_clustersC1","Gene_clustersC2","Gene_clustersC4")), listValues=c(1, -1/3)) %>% as.data.frame(.)
C3_clusters$Selected_gene <- rep("",nrow(C3_clusters))
c3_consensus_gene <- intersect(rownames(gene_annot), intersect(selected_genes_clusters$boruta, intersect(selected_genes_clusters$lrt, gene_cluster3.feat)))
C3_clusters[c3_consensus_gene,"Selected_gene"] <- gene_annot[c3_consensus_gene, "gene_name"]
EnhancedVolcano(C3_clusters,lab = C3_clusters$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "Gene Vocalno, Cluster3 vs. All\nLabeled Gene Name Consensus for Feature Selections",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```

C4

```{r, fig.height = 18, fig.width = 20}
C4_clusters <- results(DESeq.gene.clusters, independentFiltering = TRUE, contrast = list(c("Gene_clustersC4"), c("Gene_clustersC1","Gene_clustersC2","Gene_clustersC3")), listValues=c(1, -1/3)) %>% as.data.frame(.)
C4_clusters$Selected_gene <- rep("",nrow(C4_clusters))
c4_consensus_gene <- intersect(rownames(gene_annot), intersect(selected_genes_clusters$boruta, intersect(selected_genes_clusters$lrt, gene_cluster4.feat)))
C4_clusters[c4_consensus_gene,"Selected_gene"] <- gene_annot[c4_consensus_gene, "gene_name"]
EnhancedVolcano(C4_clusters,lab = C4_clusters$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "Gene Vocalno, Cluster4 vs. All\nLabeled Gene Name Consensus for Feature Selections",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```


### Primary vs. Metastatic

```{r}
mets_selected$Status <- as.factor(mets_selected$Status)
#create the object
DESeq.gene.pm <- DESeqDataSetFromMatrix(countData = filtered_gene_counts[,rownames(mets_selected)],
                                   colData = mets_selected,
                                   design = ~ Status)
DESeq.gene.pm$Status <- relevel(DESeq.gene.pm$Status, ref = "Primary")
```


#### Testing

Perform the test
```{r}
DESeq.gene.pm <- DESeq(DESeq.gene.pm ,parallel = T,test = "Wald")
resultsNames(DESeq.gene.pm)
```

QQ Plot

```{r}
res_gene_pm.all <- as.data.frame(results(DESeq.gene.pm))
Norm_quantile<- sort(-log10(seq(1, 1/nrow(res_gene_pm.all), length.out = nrow(res_gene_pm.all))), decreasing = TRUE)
res_gene_pm.all <-res_gene_pm.all[order(res_gene_pm.all$padj, decreasing  = FALSE),]
res_gene_pm.all["Normal_Quantile"] <- Norm_quantile
ggplot(res_gene_pm.all, aes(x = Normal_Quantile, y =-log10(padj))) + geom_point()+geom_abline(intercept = 0, slope = 1, color="red") + xlab("Negative Log Normal Quantile (Expected)")+ylab("Negative Log 10 P Values (Observed)")+ggtitle("QQ Plot for Gene, Primary vs. Metastatic")
```


### Feature Selection

#### LRT

```{r}
DESeq.gene.pm.lrt <- DESeqDataSetFromMatrix(countData = filtered_gene_counts[,rownames(mets_selected)],
                                   colData = mets_selected,
                                   design = ~ Status) 
DESeq.gene.pm.lrt <- DESeq(DESeq.gene.pm.lrt ,parallel = T,test = "LRT", reduced = ~1)
res_gene_pm <- restable(min_fc = 2, max_p = 0.01, n_top_genes = 20, DESeq.gene.pm.lrt)
```


```{r}
selected_genes_pm <- list()
selected_genes_pm$lrt <- rownames(res_gene_pm) 
```



#### Boruta

```{r}
genes.pm.vst <- assay(varianceStabilizingTransformation(DESeq.gene.pm))
ntop.gene.pm <- nrow(genes.pm.vst)
vars.gene.pm <- rowVars(genes.pm.vst)
Vstmat.gene.pm <- genes.pm.vst[order(-vars.gene.pm)[1:ntop.gene.pm],]
```


```{r, message = FALSE}
set.seed(12345678)
bor.orig.pm.gene <- Boruta(x = t(Vstmat.gene.pm), y = mets_selected$Status, doTrace=2, ntree = 1000, maxRuns = 1000)
print(bor.orig.pm.gene)
bor.model.pm.gene <- TentativeRoughFix(bor.orig.pm.gene)
print(bor.model.pm.gene)
selected_genes_pm$boruta <- names(bor.model.pm.gene$finalDecision)[bor.model.pm.gene$finalDecision == 'Confirmed']
```

#### LASSO

```{r}
set.seed(123456)
gene.pm_cv <- cv.glmnet(x = t(Vstmat.gene.pm), y = mets_selected$Status, family="binomial",intercept = F, alpha=1)
gene.pm.cf <- coef(gene.pm_cv , gene.pm_cv$lambda.1se)
gene.pm.features <- as.data.frame(gene.pm.cf)
gene.pm.feat.lasso<- rownames(gene.pm.features)[gene.pm.features!=0]
selected_genes_pm$lasso <- gene.pm.feat.lasso
``` 


#### Consensus

```{r}
upset(fromList(selected_genes_pm), 
      sets=c('lrt', 'boruta','lasso'), 
      order.by = "freq",
      text.scale = c(1.5, 1.5, 1.3, 1.3, 1.3, 1.3))
```


Heatmap table

```{r}
#Add a column to res_gene_pm about the feature selection results
res_gene_pm.all$Feature_Select <- rep(NA,nrow(res_gene_pm.all))
#lrt
res_gene_pm.all[selected_genes_pm$lrt,"Feature_Select"] <- "LRT Unique"
#boruta
res_gene_pm.all[selected_genes_pm$boruta,"Feature_Select"] <- "BORUTA Unique"
#lasso
res_gene_pm.all[selected_genes_pm$lasso,"Feature_Select"] <- "LASSO Unique"
#boruta & lasso
las_bor <- intersect(selected_genes_pm$boruta,selected_genes_pm$lasso)
res_gene_pm.all[las_bor,"Feature_Select"] <- "BORUTA and LASSO"
#boruta & lrt
bor_lrt <- intersect(selected_genes_pm$boruta,selected_genes_pm$lrt)
res_gene_pm.all[bor_lrt,"Feature_Select"] <- "BORUTA and LRT"
#lasso & lrt
las_lrt <- intersect(selected_genes_pm$lasso,selected_genes_pm$lrt)
res_gene_pm.all[las_lrt,"Feature_Select"] <- "LASSO and LRT"
#all three
all_3_gene <- intersect(las_lrt,selected_genes_pm$boruta)
res_gene_pm.all[all_3_gene,"Feature_Select"] <- "All Consensus"
#none (to be removed)
gene_heat_pm <- genes.pm.vst[rownames(res_gene_pm.all)[(!is.na(res_gene_pm.all$Feature_Select))],]
res_gene_pm_selected <- res_gene_pm.all[rownames(res_gene_pm.all)[(!is.na(res_gene_pm.all$Feature_Select))],]
metadata_rows_status <- mets_selected[order(mets_selected[,"Status"], mets_selected[,"Gene_clusters"]),] %>% rownames(.)
gene_heat_pm  <- gene_heat_pm[,metadata_rows_status]
```



#### Functional pathway analyses and reordering the gene rows

Adapted from (hbctraining)[https://hbctraining.github.io/DGE_workshop_salmon/lessons/functional_analysis_2019.html]
```{r}
gene.pm.go <- enrichGO(gene = as.character(gene_annot[rownames(res_gene_pm_selected), "gene_name"]),
                            universe = as.character(gene_annot[rownames(res_gene_pm.all), "gene_name"]),
                            keyType = "SYMBOL",
                            OrgDb = org.Hs.eg.db, 
                            ont = "BP", 
                            pAdjustMethod = "BH", 
                            qvalueCutoff = 0.05, 
                            readable = TRUE )
gene.pm.go.summary <- as.data.frame(gene.pm.go)
```



#### Visualization

Gene functional analyses

```{r, fig.height=12, fig.width = 6}
dotplot(gene.pm.go, showCategory = 20) + ggtitle("Enrichment Analysis\nSignificant DE Genes Metastatic vs. Primary")+theme( plot.title=element_text(size=12,face="bold"),axis.title=element_text(size=8))

```



```{r, fig.height= 20, fig.width = 20}
gene_pm_pair <- enrichplot::pairwise_termsim(gene.pm.go)
emapplot(gene_pm_pair, showCategory = 20) + ggtitle("Enrichment Map\nSignificant DE Genes Metastatic vs. Primary")+theme( plot.title=element_text(size=50,face="bold"),axis.title=element_text(size=20,face="bold"))

```




#### Visualization

Heatmap

```{r,fig.height = 18, fig.width = 15}
breaklist <- seq(-3, 3, by = 0.25)
feature_col_genes <- feature_col[unique(res_gene_pm_selected$Feature_Select)]
pheatmap(gene_heat_pm, scale="row",main = "Feature Selected DE Genes, by Status",fontsize = 20, size = 35, color = inferno(25), show_rownames = FALSE, show_colnames = FALSE,cluster_cols = FALSE, cluster_rows = TRUE, breaks = breaklist, legend_labels = "Expression Z-score", annotation_col = mets_selected[,c("Status","Gene_clusters"), drop = FALSE],annotation_row = res_gene_pm_selected[,"Feature_Select",drop = FALSE], gaps_col = 207,annotation_colors = list(Gene_clusters = cluster_col_genes,Status = status_col, Feature_Select = feature_col_genes))
```

Volcano Plot

```{r, fig.height = 18, fig.width = 20}
selected_features <- all_3_gene
res_gene_pm.all$Selected_gene <- rep("",nrow(res_gene_pm.all))
res_gene_pm.all[selected_features,"Selected_gene"] <- selected_features
consensus_gene_name <- intersect(rownames(gene_annot), selected_features)
res_gene_pm.all[consensus_gene_name,"Selected_gene"] <- gene_annot[consensus_gene_name, "gene_name"]
EnhancedVolcano(res_gene_pm.all,lab = res_gene_pm.all$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "Gene Vocalno, Primary vs. Metastatic\nShowing Only All Selected Consensus",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```


#### Compute survival rates For metastatic and primary


Make the survival table
```{r}
pm_table <-  dplyr::select(mets_selected, status = c("Status"), vital_status = c("CURATED_MELANOMA_SPECIFIC_VITAL_STATUS..0....ALIVE.OR.CENSORED...1....DEAD.OF.MELANOMA.."), dates = c("CURATED_TCGA_DAYS_TO_DEATH_OR_LAST_FU"))

pm_table$status <- as.factor(pm_table$status)
pm_table$vital_status <- as.numeric(pm_table$vital_status)
pm_table$dates <- as.numeric(pm_table$dates)
```


The Survival Analysis

```{r}
pm_surv <- survfit(Surv(dates, vital_status) ~ status,
    conf.type = "log", data = pm_table)
ggsurvplot(pm_surv, pval = TRUE)
```

It looks like for the primary samples, the survival fu lost track around time ~ 800

## HERVs


```{r}
filtered_herv_counts <- raw_herv[DESeq.herv.un.pca$xvars,]
```

### Between Clusters

#### 1. 2-Cluster
```{r}
#create the object
DESeq.herv.clusters <- DESeqDataSetFromMatrix(countData = filtered_herv_counts[,rownames(metadata)],
                                   colData = metadata,
                                   design = ~ HERV_Clusters)
```


#### Process count info 
```{r, fig.width = 10, fig.height = 5}
#size factor
DESeq.herv.clusters <- estimateSizeFactors(DESeq.herv.clusters)
#normalize & log-sized
DESeq.herv.clusters_norm <- counts(DESeq.herv.clusters, normalized = TRUE)
boxplot(log2(DESeq.herv.clusters_norm+1), notch=FALSE, main = "Size-factor-normalized read counts\nHERV Counts", ylab="log2(read counts)", cex = .6, las = 2)
assay(DESeq.herv.clusters,"log.norm.counts") <- log2(DESeq.herv.clusters_norm+1)
```


```{r}
#SD and PCA plot
msd.herv <- vsn::meanSdPlot(DESeq.herv.clusters@assays@data@listData$log.norm.counts, ranks=FALSE, plot = FALSE)
msd.herv$gg + ggtitle("Sequencing depth normalized log2(read counts), HERVs") + ylab("standard deviation")
```

Perform the test
```{r}
DESeq.herv.clusters <- DESeq(DESeq.herv.clusters ,parallel = T,test = "Wald")
resultsNames(DESeq.herv.clusters)
```

QQ Plot

```{r}
res_herv_clusters.all <- as.data.frame(results(DESeq.herv.clusters))
Norm_quantile<- sort(-log10(seq(1, 1/nrow(res_herv_clusters.all), length.out = nrow(res_herv_clusters.all))), decreasing = TRUE)
res_herv_clusters.all <-res_herv_clusters.all[order(res_herv_clusters.all$padj, decreasing  = FALSE),]
res_herv_clusters.all["Normal_Quantile"] <- Norm_quantile
ggplot(res_herv_clusters.all, aes(x = Normal_Quantile, y =-log10(padj))) + geom_point()+geom_abline(intercept = 0, slope = 1, color="red") + xlab("Negative Log Normal Quantile (Expected)")+ylab("Negative Log 10 P Values (Observed)")+ggtitle("QQ Plot for Computed Cluster Gene Expression")
```


### Feature Selection

#### LRT

```{r}
DESeq.herv.clusters.lrt <- DESeqDataSetFromMatrix(countData = filtered_herv_counts[,rownames(metadata)],
                                   colData = metadata,
                                   design = ~ HERV_Clusters) 
DESeq.herv.clusters.lrt <- DESeq(DESeq.herv.clusters.lrt ,parallel = T,test = "LRT", reduced = ~1)
res_herv_clusters <- restable(min_fc = 2, max_p = 0.01, n_top_genes = 20, DESeq.herv.clusters.lrt)
```


```{r}
selected_herv_clusters <- list()
selected_herv_clusters$lrt <- rownames(res_herv_clusters) 
```



#### Boruta

```{r}
herv.clusters.vst <- assay(varianceStabilizingTransformation(DESeq.herv.clusters))
ntop.herv.c <- nrow(herv.clusters.vst)
vars.herv.c <- rowVars(herv.clusters.vst)
Vstmat.herv.clusters <- herv.clusters.vst[order(-vars.herv.c)[1:ntop.herv.c],]
```


```{r, message = FALSE}
set.seed(12345678)
bor.orig.cluster.herv <- Boruta(x = t(Vstmat.herv.clusters), y = metadata$HERV_Clusters, doTrace=2, ntree = 1000, maxRuns = 1000)
print(bor.orig.cluster.herv)
bor.model.cluster.herv <- TentativeRoughFix(bor.orig.cluster.herv)
print(bor.model.cluster.herv)
selected_herv_clusters$boruta <- names(bor.model.cluster.herv$finalDecision)[bor.model.cluster.herv$finalDecision == 'Confirmed']
```

#### LASSO

```{r}
set.seed(123456)
herv.cluster_cv <- cv.glmnet(x = t(Vstmat.herv.clusters), y = metadata$HERV_Clusters, family="binomial",intercept = F, alpha=1)

herv.cluster.cf <- coef(herv.cluster_cv , herv.cluster_cv$lambda.1se)
herv_cluster.features <- as.data.frame(herv.cluster.cf)
herv_cluster.feat<- rownames(herv_cluster.features)[herv_cluster.features!=0]

selected_herv_clusters$lasso <- herv_cluster.feat
``` 


#### Consensus

```{r}
upset(fromList(selected_herv_clusters), 
      sets=c('lrt', 'boruta','lasso'), 
      order.by = "freq",
      text.scale = c(1.5, 1.5, 1.3, 1.3, 1.3, 1.3))
```


Heatmap table

```{r}
#Add a column to res_herv_clusters.all about the feature selection results
res_herv_clusters.all$Feature_Select <- rep(NA,nrow(res_herv_clusters.all))
#lrt
res_herv_clusters.all[selected_herv_clusters$lrt,"Feature_Select"] <- "LRT Unique"
#boruta
res_herv_clusters.all[selected_herv_clusters$boruta,"Feature_Select"] <- "BORUTA Unique"
#lasso
res_herv_clusters.all[selected_herv_clusters$lasso,"Feature_Select"] <- "LASSO Unique"
#boruta & lasso
las_bor <- intersect(selected_herv_clusters$boruta,selected_herv_clusters$lasso)
res_herv_clusters.all[las_bor,"Feature_Select"] <- "BORUTA and LASSO"
#boruta & lrt
bor_lrt <- intersect(selected_herv_clusters$boruta,selected_herv_clusters$lrt)
res_herv_clusters.all[bor_lrt,"Feature_Select"] <- "BORUTA and LRT"
#lasso & lrt
las_lrt <- intersect(selected_herv_clusters$lasso,selected_herv_clusters$lrt)
res_herv_clusters.all[las_lrt,"Feature_Select"] <- "LASSO and LRT"
#all three
all_3_herv <- intersect(las_lrt,selected_herv_clusters$boruta)
res_herv_clusters.all[all_3_herv,"Feature_Select"] <- "All Consensus"
#none (to be removed)
heat_herv_clusters <- herv.clusters.vst[rownames(res_herv_clusters.all)[(!is.na(res_herv_clusters.all$Feature_Select))],]
res_herv_clusters_selected <- res_herv_clusters.all[rownames(res_herv_clusters.all)[(!is.na(res_herv_clusters.all$Feature_Select))],]
heat_herv_clusters <- heat_herv_clusters[,unsupervised.herv.clusters[[2]]$consensusTree$order]
```




#### Visualization

Heatmap

```{r,fig.height = 18, fig.width = 15}
breaklist <- seq(-3, 3, by = 0.25)
feature_col_herv <- feature_col[unique(res_herv_clusters_selected$Feature_Select)]
cluster_col_herv <- cluster_col[c("C1","C2")]
pheatmap(heat_herv_clusters, scale="row",main = "Feature Selected DE HERVs, Computed Clusters",fontsize = 20, size = 35, color = inferno(25), show_rownames = FALSE, show_colnames = FALSE,cluster_cols = FALSE, cluster_rows = TRUE, breaks = breaklist, legend_labels = "Expression Z-score", annotation_col = metadata[,c("HERV_Clusters","Status"), drop = FALSE],annotation_row = res_herv_clusters_selected[,"Feature_Select",drop = FALSE], gaps_col = 159,annotation_colors = list(HERV_Clusters = cluster_col_herv,Status = status_col, Feature_Select = feature_col_herv))
```

```{r,fig.height = 10, fig.width = 18}
herv_heat_clusters_sub <-heat_herv_clusters[all_3_herv, ,drop = FALSE]
pheatmap(herv_heat_clusters_sub, scale="row",main = "Feature Selected DE HERVs, Between Clusters\nShowing Only All Selected Consensus",fontsize = 20, size = 35, color = inferno(25), show_rownames = TRUE, show_colnames = FALSE,cluster_cols = FALSE, cluster_rows = TRUE, breaks = breaklist, legend_labels = "Expression Z-score", annotation_col = metadata[,c("HERV_Clusters","Status"), drop = FALSE], gaps_col = 159,annotation_colors = list(HERV_Clusters = cluster_col_herv,Status = status_col))
```

Volcano Plot

```{r, fig.height = 18, fig.width = 20}
res_herv_clusters.all$Selected_gene <- rep("",nrow(res_herv_clusters.all))
res_herv_clusters.all[all_3_herv,"Selected_gene"] <- all_3_herv

EnhancedVolcano(res_herv_clusters.all,lab = res_herv_clusters.all$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "HERV Vocalno, Between Clusters\nLabeled HERVs Consensus for Feature Selections",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```



### Primary vs. Metastatic

```{r}
#create the object
DESeq.herv.pm <- DESeqDataSetFromMatrix(countData = filtered_herv_counts[,rownames(metadata)],
                                   colData = metadata,
                                   design = ~ Status)
DESeq.herv.pm$Status <- relevel(DESeq.herv.pm$Status, ref = "Primary")
```


#### Testing

Perform the test
```{r}
DESeq.herv.pm <- DESeq(DESeq.herv.pm ,parallel = T,test = "Wald")
resultsNames(DESeq.herv.pm)
```

QQ Plot

```{r}
res_herv_pm.all <- as.data.frame(results(DESeq.herv.pm))
Norm_quantile<- sort(-log10(seq(1, 1/nrow(res_herv_pm.all), length.out = nrow(res_herv_pm.all))), decreasing = TRUE)
res_herv_pm.all <-res_herv_pm.all[order(res_herv_pm.all$padj, decreasing  = FALSE),]
res_herv_pm.all["Normal_Quantile"] <- Norm_quantile
ggplot(res_herv_pm.all, aes(x = Normal_Quantile, y =-log10(padj))) + geom_point()+geom_abline(intercept = 0, slope = 1, color="red") + xlab("Negative Log Normal Quantile (Expected)")+ylab("Negative Log 10 P Values (Observed)")+ggtitle("QQ Plot for HERVs, Primary vs. Metastatic")
```


### Feature Selection

#### LRT

```{r}
DESeq.herv.pm.lrt <- DESeqDataSetFromMatrix(countData = filtered_herv_counts[,rownames(metadata)],
                                   colData = metadata,
                                   design = ~ Status) 
DESeq.herv.pm.lrt <- DESeq(DESeq.herv.pm.lrt ,parallel = T,test = "LRT", reduced = ~1)
res_herv_pm <- restable(min_fc = 2, max_p = 0.01, n_top_genes = 20, DESeq.herv.pm.lrt)
```


```{r}
selected_herv_pm <- list()
selected_herv_pm$lrt <- rownames(res_herv_pm) 
```



#### Boruta

```{r}
herv.pm.vst <- assay(varianceStabilizingTransformation(DESeq.herv.pm))
ntop.herv.pm <- nrow(herv.pm.vst)
vars.herv.pm <- rowVars(herv.pm.vst)
Vstmat.herv.pm <- herv.pm.vst[order(-vars.herv.pm)[1:ntop.herv.pm],]
```


```{r, message = FALSE}
set.seed(12345678)
bor.orig.pm.herv <- Boruta(x = t(Vstmat.herv.pm), y = metadata$HERV_Clusters, doTrace=2, ntree = 1000, maxRuns = 1000)
print(bor.orig.pm.herv)
bor.model.pm.herv <- TentativeRoughFix(bor.orig.pm.herv)
print(bor.model.pm.herv)
selected_herv_pm$boruta <- names(bor.model.pm.herv$finalDecision)[bor.model.pm.herv$finalDecision == 'Confirmed']
```

#### LASSO

```{r}
set.seed(123456)
herv.pm_cv <- cv.glmnet(x = t(Vstmat.herv.pm), y = metadata$Status, family="binomial",intercept = F, alpha=1)
herv.pm.cf <- coef(herv.pm_cv , herv.pm_cv$lambda.1se)
herv.pm.features <- as.data.frame(herv.pm.cf)
herv.pm.feat.lasso<- rownames(herv.pm.features)[herv.pm.features!=0]
selected_herv_pm$lasso <- herv.pm.feat.lasso
``` 


#### Consensus

```{r}
upset(fromList(selected_herv_pm), 
      sets=c('lrt', 'boruta','lasso'), 
      order.by = "freq",
      text.scale = c(1.5, 1.5, 1.3, 1.3, 1.3, 1.3))
```


Heatmap table

```{r}
#Add a column to res_herv_pm.all about the feature selection results
res_herv_pm.all$Feature_Select <- rep(NA,nrow(res_herv_pm.all))
#lrt
res_herv_pm.all[selected_herv_pm$lrt,"Feature_Select"] <- "LRT Unique"
#boruta
res_herv_pm.all[selected_herv_pm$boruta,"Feature_Select"] <- "BORUTA Unique"
#lasso
res_herv_pm.all[selected_herv_pm$lasso,"Feature_Select"] <- "LASSO Unique"
#boruta & lasso
las_bor <- intersect(selected_herv_pm$boruta,selected_herv_pm$lasso)
res_herv_pm.all[las_bor,"Feature_Select"] <- "BORUTA and LASSO"
#boruta & lrt
bor_lrt <- intersect(selected_herv_pm$boruta,selected_herv_pm$lrt)
res_herv_pm.all[bor_lrt,"Feature_Select"] <- "BORUTA and LRT"
#lasso & lrt
las_lrt <- intersect(selected_herv_pm$lasso,selected_herv_pm$lrt)
res_herv_pm.all[las_lrt,"Feature_Select"] <- "LASSO and LRT"
#all three
all_3_herv <- intersect(las_lrt,selected_herv_pm$boruta)
res_herv_pm.all[all_3_herv,"Feature_Select"] <- "All Consensus"
#none (to be removed)
herv_heat_pm <- herv.pm.vst[rownames(res_herv_pm.all)[(!is.na(res_herv_pm.all$Feature_Select))],]
res_herv_pm_selected <- res_herv_pm.all[rownames(res_herv_pm.all)[(!is.na(res_herv_pm.all$Feature_Select))],]
metadata_rows_status <- metadata[order(metadata[,"Status"], metadata[,"HERV_Clusters"]),] %>% rownames(.)
herv_heat_pm  <- herv_heat_pm[,metadata_rows_status]
```




#### Visualization

Heatmap

```{r,fig.height = 18, fig.width = 15}
breaklist <- seq(-3, 3, by = 0.25)
feature_col_herv <- feature_col[unique(res_herv_pm_selected$Feature_Select)]
pheatmap(herv_heat_pm, scale="row",main = "Feature Selected DE HERVs, by Status",fontsize = 20, size = 35, color = inferno(25), show_rownames = FALSE, show_colnames = FALSE,cluster_cols = FALSE, cluster_rows = TRUE, breaks = breaklist, legend_labels = "Expression Z-score", annotation_col = metadata[,c("Status","HERV_Clusters"), drop = FALSE],annotation_row = res_herv_pm_selected[,"Feature_Select",drop = FALSE], gaps_col = 265,annotation_colors = list(HERV_Clusters = cluster_col_herv,Status = status_col, Feature_Select = feature_col_herv))
```



Volcano Plot

```{r, fig.height = 18, fig.width = 20}
selected_features <- union(selected_herv_pm$lasso, bor_lrt)
res_herv_pm.all$Selected_gene <- rep("",nrow(res_herv_pm.all))
res_herv_pm.all[selected_features,"Selected_gene"] <- selected_features
EnhancedVolcano(res_herv_pm.all,lab = res_herv_pm.all$Selected_gene , x = 'log2FoldChange', y = 'padj', pCutoff = 0.01,FCcutoff = 2,title = "HERV Vocalno, Primary vs. Metastatic\nShowing LASSO and Consensus between LRT and BORUTA",labSize = 10,  captionLabSize = 40, axisLabSize = 40, legendLabSize = 40, max.overlaps = Inf, drawConnectors = TRUE,arrowheads = FALSE,colAlpha = 1/2,col = c("black", "forestgreen", "yellow", "red2"),pointSize = 3)+theme( plot.title=element_text(size=45,face="bold"),axis.title=element_text(size=45,face="bold"))
```

